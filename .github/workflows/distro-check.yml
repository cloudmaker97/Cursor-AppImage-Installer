name: Auto Download and Test Cursor Installation

on:
  schedule:
    # Run every Monday at 09:00 UTC to check for new versions
    - cron: '0 9 * * 1'
  workflow_dispatch:
    inputs:
      test_distros:
        description: 'Comma-separated list of distros to test'
        required: false
        default: 'ubuntu-22.04,ubuntu-20.04'
        type: string
      force_download:
        description: 'Force re-download even if AppImage exists'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  issues: write

jobs:
  download-cursor:
    runs-on: ubuntu-latest
    name: Download Latest Cursor AppImage
    outputs:
      cursor-version: ${{ steps.download.outputs.cursor-version }}
      download-url: ${{ steps.download.outputs.download-url }}
      appimage-name: ${{ steps.download.outputs.appimage-name }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y curl jq wget python3 python3-pip
        pip3 install playwright beautifulsoup4 requests
        playwright install chromium
        
    - name: Download latest Cursor AppImage
      id: download
      run: |
        echo "üîç Fetching download information from cursor.com..."
        
        # Create Python script to handle dynamic download
        cat > download_cursor.py << 'EOF'
import asyncio
from playwright.async_api import async_playwright
import json
import sys
import os

async def get_download_url():
    async with async_playwright() as p:
        try:
            # Launch browser
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(
                user_agent='Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            )
            page = await context.new_page()
            
            print("üåê Navigating to cursor.com/downloads...")
            await page.goto('https://cursor.com/downloads', wait_until='networkidle')
            
            # Wait for the page to load completely
            await page.wait_for_timeout(3000)
            
            # Look for Linux download button - try multiple selectors
            linux_selectors = [
                'button:has-text("Linux")',
                '[data-os="linux"]',
                'button:has-text("x64")',
                '.download-linux',
                'button[data-platform="linux"]',
                'a[href*="linux"]',
                'a[href*="AppImage"]'
            ]
            
            download_url = None
            
            # Try to find and click the Linux download button
            for selector in linux_selectors:
                try:
                    element = await page.query_selector(selector)
                    if element:
                        print(f"‚úÖ Found Linux button with selector: {selector}")
                        
                        # Set up network monitoring to catch the download URL
                        download_urls = []
                        
                        def handle_response(response):
                            url = response.url
                            if '.AppImage' in url or ('cursor' in url.lower() and 'linux' in url.lower()):
                                download_urls.append(url)
                                print(f"üì• Captured download URL: {url}")
                        
                        page.on('response', handle_response)
                        
                        # Click the button
                        await element.click()
                        await page.wait_for_timeout(2000)
                        
                        if download_urls:
                            download_url = download_urls[0]
                            break
                            
                except Exception as e:
                    print(f"‚ùå Selector {selector} failed: {e}")
                    continue
            
            # Alternative: Try to find download URLs in network requests
            if not download_url:
                print("üîç Searching for download URLs in page content...")
                
                # Check for any AppImage links that might be hidden
                content = await page.content()
                
                # Look for patterns in the HTML
                import re
                appimage_pattern = r'https?://[^\s"\'<>]+\.AppImage'
                urls = re.findall(appimage_pattern, content)
                
                if urls:
                    download_url = urls[0]
                    print(f"‚úÖ Found AppImage URL in content: {download_url}")
            
            await browser.close()
            
            if download_url:
                return download_url
            else:
                print("‚ùå Could not find download URL")
                return None
                
        except Exception as e:
            print(f"‚ùå Browser automation failed: {e}")
            return None

# Run the async function
download_url = asyncio.run(get_download_url())
if download_url:
    print(f"SUCCESS:{download_url}")
else:
    print("FAILED:No download URL found")
EOF

        echo "ü§ñ Running browser automation to get download URL..."
        RESULT=$(python3 download_cursor.py)
        
        if echo "$RESULT" | grep -q "SUCCESS:"; then
          LINUX_URL=$(echo "$RESULT" | grep "SUCCESS:" | cut -d: -f2-)
          echo "‚úÖ Found download URL via browser automation: $LINUX_URL"
        else
          echo "‚ùå Browser automation failed, trying API fallback..."
          
          # Enhanced GitHub API fallback with better error handling
          echo "üîÑ Checking GitHub releases..."
          GITHUB_API="https://api.github.com/repos/getcursor/cursor/releases/latest"
          
          GITHUB_RESPONSE=$(curl -s "$GITHUB_API")
          if echo "$GITHUB_RESPONSE" | jq -e '.assets' >/dev/null 2>&1; then
            LINUX_URL=$(echo "$GITHUB_RESPONSE" | jq -r '.assets[]? | select(.name | test(".*[Ll]inux.*\\.AppImage$|.*x86_64.*\\.AppImage$")) | .browser_download_url' | head -1)
            
            if [ "$LINUX_URL" = "null" ] || [ -z "$LINUX_URL" ]; then
              echo "üîç Available assets:"
              echo "$GITHUB_RESPONSE" | jq -r '.assets[]? | .name' || echo "No assets found"
              
              # Try broader patterns
              LINUX_URL=$(echo "$GITHUB_RESPONSE" | jq -r '.assets[]? | select(.name | test(".*\\.AppImage$")) | .browser_download_url' | head -1)
            fi
          else
            echo "‚ùå GitHub API response invalid"
            echo "Response: $GITHUB_RESPONSE"
          fi
          
          # Last resort: Try direct URL patterns
          if [ "$LINUX_URL" = "null" ] || [ -z "$LINUX_URL" ]; then
            echo "üîÑ Trying known download patterns..."
            
            # Common cursor download patterns
            POSSIBLE_URLS=(
              "https://downloader.cursor.sh/linux/appImage/x64"
              "https://download.cursor.sh/linux/appImage/x64"
              "https://releases.cursor.com/linux/appImage/x64"
            )
            
            for url in "${POSSIBLE_URLS[@]}"; do
              echo "üß™ Testing URL: $url"
              if curl -s -I "$url" | grep -q "200 OK"; then
                LINUX_URL="$url"
                echo "‚úÖ Found working direct URL: $url"
                break
              fi
            done
          fi
        fi
        
        # Final check
        if [ -z "$LINUX_URL" ] || [ "$LINUX_URL" = "null" ]; then
          echo "‚ùå All download methods failed"
          echo "üÜò Manual intervention required - please check cursor.com/downloads"
          exit 1
        fi
        
        echo "‚úÖ Final download URL: $LINUX_URL"
        
        # Extract version and filename
        APPIMAGE_NAME=$(basename "$LINUX_URL" | sed 's/?.*$//')
        if [ -z "$APPIMAGE_NAME" ] || [ "$APPIMAGE_NAME" = "/" ]; then
          # Generate filename if we can't extract it
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          APPIMAGE_NAME="Cursor-${TIMESTAMP}-x86_64.AppImage"
        fi
        
        VERSION=$(echo "$APPIMAGE_NAME" | grep -oP '\d+\.\d+\.\d+' || echo "unknown")
        
        echo "üì¶ AppImage name: $APPIMAGE_NAME"
        echo "üè∑Ô∏è Version: $VERSION"
        
        # Check if we already have this version (unless force download)
        if [ -f "$APPIMAGE_NAME" ] && [ "${{ inputs.force_download }}" != "true" ]; then
          echo "‚ÑπÔ∏è AppImage already exists, skipping download"
        else
          echo "‚¨áÔ∏è Downloading Cursor AppImage..."
          
          # Download with better error handling
          if wget --progress=bar:force:noscroll --timeout=300 --tries=3 -O "$APPIMAGE_NAME" "$LINUX_URL"; then
            echo "‚úÖ Download completed successfully"
          else
            echo "‚ùå Download failed with wget, trying curl..."
            if curl -L --progress-bar --max-time 300 --retry 3 -o "$APPIMAGE_NAME" "$LINUX_URL"; then
              echo "‚úÖ Download completed with curl"
            else
              echo "‚ùå All download attempts failed"
              exit 1
            fi
          fi
        fi
        
        # Verify download
        if [ ! -f "$APPIMAGE_NAME" ]; then
          echo "‚ùå AppImage file not found after download"
          exit 1
        fi
        
        FILE_SIZE=$(stat -c%s "$APPIMAGE_NAME" 2>/dev/null || stat -f%z "$APPIMAGE_NAME" 2>/dev/null || echo "0")
        if [ "$FILE_SIZE" -lt 10000000 ]; then  # Less than 10MB is suspicious
          echo "‚ö†Ô∏è Downloaded file seems too small ($FILE_SIZE bytes)"
          echo "File content preview:"
          head -20 "$APPIMAGE_NAME" || true
        fi
        
        echo "üìè File size: $(($FILE_SIZE / 1024 / 1024)) MB"
        
        # Make executable
        chmod +x "$APPIMAGE_NAME"
        
        # Test if it's a valid AppImage
        if ./"$APPIMAGE_NAME" --appimage-extract >/dev/null 2>&1; then
          echo "‚úÖ AppImage validation successful"
          rm -rf squashfs-root
        else
          echo "‚ö†Ô∏è AppImage validation failed (might still work)"
        fi
        
        # Set outputs
        echo "cursor-version=$VERSION" >> $GITHUB_OUTPUT
        echo "download-url=$LINUX_URL" >> $GITHUB_OUTPUT
        echo "appimage-name=$APPIMAGE_NAME" >> $GITHUB_OUTPUT
        
        # Create summary
        echo "## üì• Download Results" >> $GITHUB_STEP_SUMMARY
        echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Version | $VERSION |" >> $GITHUB_STEP_SUMMARY
        echo "| Filename | $APPIMAGE_NAME |" >> $GITHUB_STEP_SUMMARY
        echo "| Size | $(($FILE_SIZE / 1024 / 1024)) MB |" >> $GITHUB_STEP_SUMMARY
        echo "| Download URL | $LINUX_URL |" >> $GITHUB_STEP_SUMMARYOAD_PAGE" > downloads.html
        
        # Extract the Linux AppImage download URL
        # Look for patterns like: href="https://...cursor...AppImage" or data-download-url
        LINUX_URL=$(grep -oP 'href="[^"]*[Ll]inux[^"]*\.AppImage"' downloads.html | head -1 | sed 's/href="//;s/"//' || true)
        
        if [ -z "$LINUX_URL" ]; then
          # Try alternative patterns
          LINUX_URL=$(grep -oP 'href="[^"]*x86_64[^"]*\.AppImage"' downloads.html | head -1 | sed 's/href="//;s/"//' || true)
        fi
        
        if [ -z "$LINUX_URL" ]; then
          # Try data attributes
          LINUX_URL=$(grep -oP 'data-download-url="[^"]*[Ll]inux[^"]*\.AppImage"' downloads.html | head -1 | sed 's/data-download-url="//;s/"//' || true)
        fi
        
        if [ -z "$LINUX_URL" ]; then
          echo "‚ùå Could not find Linux AppImage download URL"
          echo "Available links in page:"
          grep -oP 'href="[^"]*\.AppImage[^"]*"' downloads.html || echo "No AppImage links found"
          
          # Fallback: Use GitHub releases as backup
          echo "üîÑ Trying GitHub releases as fallback..."
          GITHUB_API="https://api.github.com/repos/getcursor/cursor/releases/latest"
          LINUX_URL=$(curl -s "$GITHUB_API" | jq -r '.assets[] | select(.name | test(".*[Ll]inux.*\\.AppImage$")) | .browser_download_url' | head -1)
        fi
        
        if [ -z "$LINUX_URL" ] || [ "$LINUX_URL" = "null" ]; then
          echo "‚ùå Failed to find download URL from both cursor.com and GitHub"
          exit 1
        fi
        
        echo "‚úÖ Found download URL: $LINUX_URL"
        
        # Extract version and filename
        APPIMAGE_NAME=$(basename "$LINUX_URL")
        VERSION=$(echo "$APPIMAGE_NAME" | grep -oP '\d+\.\d+\.\d+' || echo "unknown")
        
        echo "üì¶ AppImage name: $APPIMAGE_NAME"
        echo "üè∑Ô∏è Version: $VERSION"
        
        # Check if we already have this version (unless force download)
        if [ -f "$APPIMAGE_NAME" ] && [ "${{ inputs.force_download }}" != "true" ]; then
          echo "‚ÑπÔ∏è AppImage already exists, skipping download"
        else
          echo "‚¨áÔ∏è Downloading Cursor AppImage..."
          if wget -O "$APPIMAGE_NAME" "$LINUX_URL"; then
            echo "‚úÖ Download completed successfully"
          else
            echo "‚ùå Download failed"
            exit 1
          fi
        fi
        
        # Verify download
        if [ ! -f "$APPIMAGE_NAME" ]; then
          echo "‚ùå AppImage file not found after download"
          exit 1
        fi
        
        FILE_SIZE=$(stat -f%z "$APPIMAGE_NAME" 2>/dev/null || stat -c%s "$APPIMAGE_NAME")
        echo "üìè File size: $(($FILE_SIZE / 1024 / 1024)) MB"
        
        # Make executable
        chmod +x "$APPIMAGE_NAME"
        
        # Set outputs
        echo "cursor-version=$VERSION" >> $GITHUB_OUTPUT
        echo "download-url=$LINUX_URL" >> $GITHUB_OUTPUT
        echo "appimage-name=$APPIMAGE_NAME" >> $GITHUB_OUTPUT
        
        # Create summary
        echo "## üì• Download Results" >> $GITHUB_STEP_SUMMARY
        echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Version | $VERSION |" >> $GITHUB_STEP_SUMMARY
        echo "| Filename | $APPIMAGE_NAME |" >> $GITHUB_STEP_SUMMARY
        echo "| Size | $(($FILE_SIZE / 1024 / 1024)) MB |" >> $GITHUB_STEP_SUMMARY
        echo "| Download URL | $LINUX_URL |" >> $GITHUB_STEP_SUMMARY
        
    - name: Upload AppImage artifact
      uses: actions/upload-artifact@v4
      with:
        name: cursor-appimage
        path: "*.AppImage"
        retention-days: 7

  test-installation:
    needs: download-cursor
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            distro: "Ubuntu 22.04"
            setup: |
              sudo apt-get update
              sudo apt-get install -y fuse3 libfuse2 desktop-file-utils
          - os: ubuntu-20.04
            distro: "Ubuntu 20.04"
            setup: |
              sudo apt-get update
              sudo apt-get install -y fuse libfuse2 desktop-file-utils
          # Add more distros using containers
          - os: ubuntu-latest
            distro: "Fedora 39"
            container: "fedora:39"
            setup: |
              dnf update -y
              dnf install -y fuse3 fuse desktop-file-utils findutils
          - os: ubuntu-latest
            distro: "Arch Linux"
            container: "archlinux:latest"
            setup: |
              pacman -Syu --noconfirm
              pacman -S --noconfirm fuse3 fuse2 desktop-file-utils findutils
          - os: ubuntu-latest
            distro: "openSUSE Tumbleweed"
            container: "opensuse/tumbleweed:latest"
            setup: |
              zypper refresh
              zypper install -y fuse3 fuse desktop-file-utils findutils
    
    runs-on: ${{ matrix.os }}
    container: ${{ matrix.container }}
    name: Test on ${{ matrix.distro }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Download AppImage artifact
      uses: actions/download-artifact@v4
      with:
        name: cursor-appimage
        
    - name: Setup test environment
      run: |
        echo "üîß Setting up ${{ matrix.distro }}..."
        ${{ matrix.setup }}
        
        # Create test user home directory structure
        export HOME="${HOME:-/root}"
        mkdir -p "$HOME/.local/share/applications"
        mkdir -p "$HOME/.local/share/icons"
        mkdir -p "$HOME/.local/bin"
        
        echo "‚úÖ Environment setup completed"
        
    - name: Validate AppImage
      run: |
        echo "üîç Validating downloaded AppImage..."
        
        APPIMAGE_FILE=$(ls *.AppImage | head -1)
        if [ -z "$APPIMAGE_FILE" ]; then
          echo "‚ùå No AppImage file found"
          exit 1
        fi
        
        echo "üì¶ Found AppImage: $APPIMAGE_FILE"
        
        # Check if file is executable
        if [ ! -x "$APPIMAGE_FILE" ]; then
          echo "‚ö†Ô∏è AppImage not executable, fixing..."
          chmod +x "$APPIMAGE_FILE"
        fi
        
        # Try to extract (test if AppImage is valid)
        echo "üîß Testing AppImage extraction..."
        if ./"$APPIMAGE_FILE" --appimage-extract >/dev/null 2>&1; then
          echo "‚úÖ AppImage extraction successful"
          rm -rf squashfs-root
        else
          echo "‚ùå AppImage extraction failed"
          exit 1
        fi
        
    - name: Run installation script
      run: |
        echo "üöÄ Running Cursor installation script on ${{ matrix.distro }}..."
        
        # Run the installation script
        if ./install_cursor.sh; then
          echo "‚úÖ Installation completed successfully"
        else
          echo "‚ùå Installation failed"
          exit 1
        fi
        
    - name: Verify installation
      run: |
        echo "üîç Verifying installation results..."
        
        # Check if desktop file was created
        DESKTOP_FILE="$HOME/.local/share/applications/cursor.desktop"
        if [ -f "$DESKTOP_FILE" ]; then
          echo "‚úÖ Desktop file created: $DESKTOP_FILE"
        else
          echo "‚ùå Desktop file not found"
          exit 1
        fi
        
        # Validate desktop file
        if command -v desktop-file-validate >/dev/null 2>&1; then
          if desktop-file-validate "$DESKTOP_FILE"; then
            echo "‚úÖ Desktop file is valid"
          else
            echo "‚ö†Ô∏è Desktop file validation warnings (may be ok)"
          fi
        fi
        
        # Check if icon was installed
        ICON_FILE="$HOME/.local/share/icons/cursor.png"
        if [ -f "$ICON_FILE" ]; then
          echo "‚úÖ Icon file created: $ICON_FILE"
          echo "üìè Icon size: $(stat -c%s "$ICON_FILE" 2>/dev/null || stat -f%z "$ICON_FILE") bytes"
        else
          echo "‚ö†Ô∏è Icon file not found (may be ok if none in AppImage)"
        fi
        
        # Check versions directory
        if [ -d "versions" ]; then
          echo "‚úÖ Versions directory created"
          echo "üìÅ Contents:"
          ls -la versions/ || true
        else
          echo "‚ùå Versions directory not found"
          exit 1
        fi
        
        # Check if current symlink exists
        if [ -L "versions/current.AppImage" ]; then
          echo "‚úÖ Current version symlink created"
          echo "üîó Points to: $(readlink versions/current.AppImage)"
        else
          echo "‚ùå Current version symlink not found"
          exit 1
        fi
        
    - name: Test AppImage execution (dry run)
      run: |
        echo "üß™ Testing AppImage execution..."
        
        CURRENT_APPIMAGE="versions/current.AppImage"
        if [ -L "$CURRENT_APPIMAGE" ]; then
          # Test with --help flag (shouldn't launch GUI)
          if timeout 30s "$CURRENT_APPIMAGE" --help >/dev/null 2>&1; then
            echo "‚úÖ AppImage can execute successfully"
          else
            echo "‚ö†Ô∏è AppImage execution test inconclusive (may need display)"
            # This is expected in headless environment
          fi
          
          # Test version info
          if timeout 10s "$CURRENT_APPIMAGE" --version 2>/dev/null | head -5; then
            echo "‚úÖ Version information retrieved"
          else
            echo "‚ÑπÔ∏è Version info not available (normal for some AppImages)"
          fi
        fi
        
    - name: Create test report
      if: always()
      run: |
        echo "## üß™ Installation Test Report - ${{ matrix.distro }}" >> test_report.md
        echo "" >> test_report.md
        echo "**AppImage:** ${{ needs.download-cursor.outputs.appimage-name }}" >> test_report.md
        echo "**Version:** ${{ needs.download-cursor.outputs.cursor-version }}" >> test_report.md
        echo "**Test Status:** $([[ $? -eq 0 ]] && echo "‚úÖ PASSED" || echo "‚ùå FAILED")" >> test_report.md
        echo "" >> test_report.md
        
        echo "### üìã Installation Results" >> test_report.md
        echo "- Desktop file: $([[ -f "$HOME/.local/share/applications/cursor.desktop" ]] && echo "‚úÖ Created" || echo "‚ùå Missing")" >> test_report.md
        echo "- Icon file: $([[ -f "$HOME/.local/share/icons/cursor.png" ]] && echo "‚úÖ Created" || echo "‚ö†Ô∏è Not found")" >> test_report.md
        echo "- Versions directory: $([[ -d "versions" ]] && echo "‚úÖ Created" || echo "‚ùå Missing")" >> test_report.md
        echo "- Current symlink: $([[ -L "versions/current.AppImage" ]] && echo "‚úÖ Created" || echo "‚ùå Missing")" >> test_report.md
        echo "" >> test_report.md
        
        # Add to step summary
        cat test_report.md >> $GITHUB_STEP_SUMMARY
        
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.distro }}-${{ github.run_number }}
        path: |
          test_report.md
          ~/.local/share/applications/cursor.desktop
          versions/
        retention-days: 30

  create-summary:
    needs: [download-cursor, test-installation]
    if: always()
    runs-on: ubuntu-latest
    name: Create Test Summary
    
    steps:
    - name: Download all test results
      uses: actions/download-artifact@v4
      with:
        pattern: test-results-*
        merge-multiple: true
        
    - name: Create comprehensive summary
      run: |
        echo "# üß™ Cursor Installation Test Summary" > summary.md
        echo "" >> summary.md
        echo "**Test Run:** $(date -u '+%Y-%m-%d %H:%M:%S') UTC" >> summary.md
        echo "**Cursor Version:** ${{ needs.download-cursor.outputs.cursor-version }}" >> summary.md
        echo "**AppImage:** ${{ needs.download-cursor.outputs.appimage-name }}" >> summary.md
        echo "" >> summary.md
        
        echo "## üìä Test Results by Distribution" >> summary.md
        echo "" >> summary.md
        
        # Combine all test reports
        for report in test_report*.md; do
          if [ -f "$report" ]; then
            cat "$report" >> summary.md
            echo "" >> summary.md
          fi
        done
        
        echo "## üîó Resources" >> summary.md
        echo "- **Download URL:** ${{ needs.download-cursor.outputs.download-url }}" >> summary.md
        echo "- **Installation Script:** [install_cursor.sh](./install_cursor.sh)" >> summary.md
        echo "- **Test Workflow:** [.github/workflows/cursor-auto-test.yml](.github/workflows/cursor-auto-test.yml)" >> summary.md
        
        # Output to step summary
        cat summary.md >> $GITHUB_STEP_SUMMARY
        
    - name: Upload final summary
      uses: actions/upload-artifact@v4
      with:
        name: test-summary-${{ github.run_number }}
        path: summary.md
        retention-days: 90
